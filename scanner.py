import sys
import requestGen
from scan import Scan
from resultSet import ResultSet
from result import Result
from spider import Spider
import presets
import argparse

#Start a scan using command line arguments
def startup_scan(args):
    #Make sure the required arguments were provided - the attacks list, url file or list
    if args.attacks is not None and (args.urlsfile is not None or args.listurl is not None):
        #if there was a filename given, keep that path as urlsfile
        if args.urlsfile is not None:
            urlsfile = args.urlsfile
        #if a list was given at the command line, write it to a text file and use that
        #path as urlsfile
        else:
            try:
                tempfile = open('output/tempurls.txt', 'w+')
                for url in args.listurl :
                    tempfile.write(url + '\n')
                tempfile.close()
                urlsfile = 'output/tempurls.txt'
            except Exception as e:
                print('error creating temporary url file from supplied url list\nError: ' + repr(e))
        #make a resultset to contain the scan results
        results = ResultSet()
        #run a scan using the attacks list and the urlsfile
        results = run_scan(args.attacks, urlsfile)
        #if the user wanted the results printed to the command line, do that,
        #otherwise print them to a text file
        if args.printout:
            print('Results of scan:\n')
            print(results.to_string())
        else:
            print(results.out_to_text_file(args.resultsfile))
    #If the user failed to supply the necessary arguments, tell them to check the help text
    else:
        print('missing arguments, please see help for details. -h, --help')

#start a spider with the arguments provided at the commmand line
def startup_spider(args):
    #if the user wanted to see presets, show them the list
    if args.show_presets:
        show_presets()
        return
    #if they provided a list of arguments, check the list
    if args.preset == None:
        #Check that the required arguments were provided
        if args.start is not None and args.domain is not None:
            #build settings from the command line arguments
            settings = build_spider_settings(args.start, args.domain, args.denystrs, args.paramrestrict, args.outputfile)
            #run a spider with the built settings
            run_spider(settings)
        #if the user missed required arguments, tell them to check the help text
        else:
            print('missing arguments, please see help for details. -h, --help')
    #Check if the preset name given is a legitimate preset
    elif args.preset in presets.get_presets_spider_list():
        #get the preset's settings
        settings = presets.get_preset_spider(args.preset)
        #run a spider with the presets
        run_spider(settings)
    #if the user missed required arguments, tell them to check the help text
    else:
        print('missing arguments, please see help for details. -h, --help')

#run a scan with the passed in attack types and url file path
def run_scan(attack_types, url_file_name):
    scan = Scan(attack_types, url_file_name)
    results = ResultSet()
    results = scan.scan()

    return results

#run a spider with the provided settings
def run_spider(spider_settings):
    spider = Spider(**spider_settings)
    spider.start_spider()

#get the ilst of presets and their details to show the user
def show_presets():
    strings = presets.get_presets_strings('spider')
    for string in strings:
        print(string)

#Make a dictionary of spider settings out of the provided details
def build_spider_settings(start_url, domain, deny_strs, param_restricted, urls_file_name):
    settings = {
        'start_url': start_url,
        'domain': domain,
        'deny_strs': deny_strs,
        'param_restricted': param_restricted,
        'urls_file_name': urls_file_name
    }
    return settings


#Make a parser for the commmand line arguments so that the user can provide details
#to the program and the program can interpret these
def build_parser():
    parser = argparse.ArgumentParser(description='run very basic spider and vulnerability scans against a web application')
    #if the user runs the program with no arguments, show them how to use it
    parser.set_defaults(func=lambda x: parser.print_usage())

    #Add subparsers to deal with the seperate spider and scan functions and their
    #related arguments
    function = parser.add_subparsers(title='functions', description='available functions', help='per-funtion help', dest='subparser')
    parser_scan = function.add_parser('scan', help='to run scan')
    parser_spider = function.add_parser('spider', help='to run spider')

    #Scan subparser arguments
    #Attack types required to be provided
    parser_scan.add_argument('-a', '--attacks', type=str, nargs='+', choices=['all', 'sqli', 'xss', 'rfi', 'cmd', 'dirb'], default='all', help='space-separated list of attacks, or \'all\'', required=True)
    #user has to provide either a url list or a file containing urls
    scan_urls = parser_scan.add_mutually_exclusive_group(required = True)
    scan_urls.add_argument('-l', '--listurl', type=str, nargs='+', help='space-separated list of urls to scan')
    scan_urls.add_argument('-u', '--urlsfile', type=str, help='path to a file with one url per line')
    #The user can either give a file to print to OR print to the console, not both
    scan_out = parser_scan.add_mutually_exclusive_group()
    scan_out.add_argument('-r', '--resultsfile', type=str, help='path to file to print results to, defaults to output/results.txt')
    scan_out.add_argument('--printout', action='store_true', help='do not print results to file, print them to the command line')
    #send scan arguments to the startup_scan function
    parser_scan.set_defaults(func=startup_scan)

    #Spider parser arguments
    parser_spider.add_argument('-s', '--start', type=str, help='url to start spider on, http://www.example.com')
    parser_spider.add_argument('-d', '--domain', type=str, help='domain, example.com')
    parser_spider.add_argument('-n', '--denystrs', type=str, nargs='*', help='space-separated list of strings that if found in a link will not be followed, example.com/not_this_subdir')
    parser_spider.add_argument('-p', '--paramrestrict', type=str, help='a parameter name that must be unique in recorded links, useful if application uses page= or action= to decide which page to load')
    parser_spider.add_argument('-o', '--outputfile', type=str, default='output/urls_spidered.txt', help='the path to a file to store the urls found in, defaults to output/urls_spidered.txt')
    parser_spider.add_argument('--preset', type=str, help='supplied instead of any other argument after --spider (\'spider --show_presets\' for list)')
    parser_spider.add_argument('--show_presets', action='store_true', help='display a list of available spider preset settings')
    #Send spider arguments to the start_spider function
    parser_spider.set_defaults(func=startup_spider)

    return parser

#Parse the arguments given by the user to the program and run the functions
#for scanning or spidering based on the user's arguments
def main():
    print('\nVery Basic Vulnerability Scanner\n' + '-'*40)
    parser = build_parser()
    args = parser.parse_args()
    args.func(args)


if __name__ == "__main__":
    main()
