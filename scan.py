import sys
import requests
from resultSet import ResultSet
from result import Result
import requestGen

#Dictionaries of attacks: a descriptive string, an attack string,
#and a string to search for in the responses
sqli = {
    'attack_string': 'SQL Injection',
    "payload": '\'',
    "search_string": 'error in your SQL syntax'
}

xss = {
    'attack_string': 'Cross Site Scripting (XSS)',
    "payload": '<script>alert(\"xss\")</script>',
    "search_string": '<script>alert(\"xss\")</script>'
}

rfi = {
    'attack_string': 'Remote File Inclusion',
    "payload": 'http://www.google.com',
    "search_string": 'Google Search'
}

cmd_win = {
    'attack_string': 'OS Command Injection',
    "payload": 'a&dir',
    "search_string": 'Directory of'
}

cmd_linux = {
    'attack_string': 'OS Command Injection',
    "payload": 'a&&ping -c 1 google.com',
    "search_string": 'google.com ping statistics'
}

dirb = {
    'attack_string': 'Directory Browsing',
    "payload": '',
    "search_string": 'Index of'
}

#The list of attacks available assigned to string keys
attacks_list = {
    'sqli': sqli,
    'xss': xss,
    'rfi': rfi,
    'cmd': cmd_win,
    'dirb': dirb
}

#A class describing a scan entity with a set of urls to scan, a set of attacks to
#try and a result set, with functions to run the scan and output results.
class Scan:
    #The urls to scan
    urls = []
    #the attack types to test
    attacks = {}
    #The results of all tests
    result_set = ResultSet()

    #Runs the scan - tries all attacks against all urls and saves the results
    def scan(self):
        #Tell the user the scan has started and how many tests will be run
        print('Starting Scan :\nTotal tests to run = ' + str(len(self.urls)*len(self.attacks)))
        #whether or not an attack succeeded
        success = False
        #total successful tries per attack type
        successes = 0
        #running total of attack types tried
        attacks_done = 0
        #number of urls tested per attack type
        urls_done = 0
        #the total number of urls to try
        urls_total = len(self.urls)
        #Loop through the attack types, trying that attack type with every url in each loop
        for attack in self.attacks:
            attacks_done += 1
            urls_done = 0
            successes = 0
            #Tell the user which attack type is being tried and which number it is out of the total
            print('\n\nattack: ' + self.attacks[attack]['attack_string'] + ', ' + str(attacks_done) + ' of ' + str(len(self.attacks)) + '\n' + '-'*45)
            #loop through all urls
            for url in self.urls:
                urls_done += 1
                #Show a progress bar based on how many of the urls have been tested for the current attack type
                self.progress_bar(urls_done, urls_total, successes)
                #check if the search string is in the page without sending an attack parameter
                success = requestGen.find_string(url, self.attacks[attack]['search_string'])
                if success:
                    successes += 1
                else:
                    #if there was nothing in the base page, try sending the payload string in every possible field
                    req_params = requestGen.gen_req_params(url, self.attacks[attack]['payload'])
                    for req_param in req_params:
                        success = requestGen.find_string(url, self.attacks[attack]['search_string'], req_param)
                        if success:
                            successes += 1
                            break
                #make a result object for the test just attempted, add it to the resultset
                result_new = Result(url, self.attacks[attack]['attack_string'], success)
                self.result_set.add(result_new)
                #reset the success for the next attempt
                success = False
            #When the attack type has been tested on every url, print a full progress bar and the number
            #of successes in that attack type
            sys.stdout.write("\rScan Progress ([{0}]) Successes : {1}\n".format('#'*20, successes))
            sys.stdout.flush()
        print('\n')
        return self.result_set

    #Generate a list of urls from a text file
    #Read in each line and if it contains 'http' add it to the list
    def get_urls_from_file(self, url_file_name):
        urls_from_file = []
        try:
            url_file = open(url_file_name, "r")
            url_line = url_file.readline()
            while url_line:
                if "http" in url_line:
                    url_line = url_line.rstrip('\r\n')
                    urls_from_file.append(url_line)
                url_line = url_file.readline()
            url_file.close()

            self.urls = urls_from_file
            return True
        except Exception as e:
            print('failed to get urls from file ' + url_file_name + '\nError: ' + repr(e))
            return False


    #Display a progress bar to the user showing the percentage
    #of urls tested out of the total to test, along with the number of successes
    #in the current attack type
    def progress_bar(self, current, total, successes):
        progress = float(current) / total
        fill = '>' * int(round(progress * 20))
        space = ' ' * (20 - len(fill))

        sys.stdout.write("Scan Progress ([{0}]) Successes : {1}\r".format(fill + space, successes))
        sys.stdout.flush()

    #Initialise a new scan with a list of attack types and urls from a file
    #If no url file is given, make an empty scan rather than an error
    def __init__(self, attack_types, url_file_name=None):
        if url_file_name is not None:
            success = self.get_urls_from_file(url_file_name)
            if not success:
                self.urls = []
        else:
            self.urls = []
        if 'all' in attack_types:
            self.attacks = attacks_list.copy()
        else:
            for attack_type in attack_types:
                self.attacks[attack_type] = attacks_list[attack_type]
